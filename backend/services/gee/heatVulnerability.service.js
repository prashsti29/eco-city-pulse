const { ee } = require('../../config/gee');
const ndviService = require('./ndvi.service');
const lstService = require('./lst.service');
const ndbiService = require('./ndbi.service');

// Calculate Heat Vulnerability Index
// HVI = (LST_normalized + NDBI_normalized - NDVI_normalized) / 3
exports.calculateHeatVulnerability = async (bounds, startDate, endDate) => {
  const geometry = ee.Geometry.Rectangle([
    bounds.west, bounds.south, bounds.east, bounds.north
  ]);

  // Get all indices
  const lst = lstService.calculateLST(bounds, startDate, endDate);
  const ndvi = ndviService.calculateNDVI(bounds, startDate, endDate);
  const ndbi = ndbiService.calculateNDBI(bounds, startDate, endDate);

  // Normalize to 0-1 range
  const lstNorm = lst.unitScale(15, 50); // Temperature range 15-50Â°C
  const ndviNorm = ndvi.unitScale(-0.5, 0.8);
  const ndbiNorm = ndbi.unitScale(-0.5, 0.5);

  // Calculate HVI (higher LST + higher NDBI - lower NDVI = higher vulnerability)
  const hvi = lstNorm.add(ndbiNorm).subtract(ndviNorm).divide(3);

  return hvi.clip(geometry);
};

exports.getHeatVulnerabilityStats = async (bounds, startDate, endDate) => {
  const hvi = await exports.calculateHeatVulnerability(bounds, startDate, endDate);

  const stats = hvi.reduceRegion({
    reducer: ee.Reducer.mean().combine({
      reducer2: ee.Reducer.minMax(),
      sharedInputs: true
    }),
    geometry: ee.Geometry.Rectangle([bounds.west, bounds.south, bounds.east, bounds.north]),
    scale: 30,
    maxPixels: 1e9
  });

  return new Promise((resolve, reject) => {
    stats.evaluate((result, error) => {
      if (error) reject(error);
      else {
        // Return vulnerability level (0-1 scale)
        const meanHVI = result.constant_mean;
        let level = 'Low';
        if (meanHVI > 0.7) level = 'Critical';
        else if (meanHVI > 0.5) level = 'High';
        else if (meanHVI > 0.3) level = 'Moderate';

        resolve({
          hvi: meanHVI?.toFixed(3),
          level: level
        });
      }
    });
  });
};